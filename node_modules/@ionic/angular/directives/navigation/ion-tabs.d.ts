import { EventEmitter } from '@angular/core';
import { NavController } from '../../providers/nav-controller';
import { IonTabBar } from '../proxies';
import { IonRouterOutlet } from './ion-router-outlet';
import { StackEvent } from './stack-utils';
import * as ɵngcc0 from '@angular/core';
export declare class IonTabs {
    private navCtrl;
    outlet: IonRouterOutlet;
    tabBar: IonTabBar | undefined;
    ionTabsWillChange: EventEmitter<{
        tab: string;
    }>;
    ionTabsDidChange: EventEmitter<{
        tab: string;
    }>;
    constructor(navCtrl: NavController);
    /**
     * @internal
     */
    onPageSelected(detail: StackEvent): void;
    /**
     * When a tab button is clicked, there are several scenarios:
     * 1. If the selected tab is currently active (the tab button has been clicked
     *    again), then it should go to the root view for that tab.
     *
     *   a. Get the saved root view from the router outlet. If the saved root view
     *      matches the tabRootUrl, set the route view to this view including the
     *      navigation extras.
     *   b. If the saved root view from the router outlet does
     *      not match, navigate to the tabRootUrl. No navigation extras are
     *      included.
     *
     * 2. If the current tab tab is not currently selected, get the last route
     *    view from the router outlet.
     *
     *   a. If the last route view exists, navigate to that view including any
     *      navigation extras
     *   b. If the last route view doesn't exist, then navigate
     *      to the default tabRootUrl
     */
    select(tab: string): Promise<boolean>;
    getSelected(): string | undefined;
    static ɵfac: ɵngcc0.ɵɵFactoryDef<IonTabs, never>;
    static ɵcmp: ɵngcc0.ɵɵComponentDefWithMeta<IonTabs, "ion-tabs", never, {}, { "ionTabsWillChange": "ionTabsWillChange"; "ionTabsDidChange": "ionTabsDidChange"; }, ["tabBar"], ["[slot=top]", "*"]>;
}

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW9uLXRhYnMuZC50cyIsInNvdXJjZXMiOlsiaW9uLXRhYnMuZC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQSIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEV2ZW50RW1pdHRlciB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xyXG5pbXBvcnQgeyBOYXZDb250cm9sbGVyIH0gZnJvbSAnLi4vLi4vcHJvdmlkZXJzL25hdi1jb250cm9sbGVyJztcclxuaW1wb3J0IHsgSW9uVGFiQmFyIH0gZnJvbSAnLi4vcHJveGllcyc7XHJcbmltcG9ydCB7IElvblJvdXRlck91dGxldCB9IGZyb20gJy4vaW9uLXJvdXRlci1vdXRsZXQnO1xyXG5pbXBvcnQgeyBTdGFja0V2ZW50IH0gZnJvbSAnLi9zdGFjay11dGlscyc7XHJcbmV4cG9ydCBkZWNsYXJlIGNsYXNzIElvblRhYnMge1xyXG4gICAgcHJpdmF0ZSBuYXZDdHJsO1xyXG4gICAgb3V0bGV0OiBJb25Sb3V0ZXJPdXRsZXQ7XHJcbiAgICB0YWJCYXI6IElvblRhYkJhciB8IHVuZGVmaW5lZDtcclxuICAgIGlvblRhYnNXaWxsQ2hhbmdlOiBFdmVudEVtaXR0ZXI8e1xyXG4gICAgICAgIHRhYjogc3RyaW5nO1xyXG4gICAgfT47XHJcbiAgICBpb25UYWJzRGlkQ2hhbmdlOiBFdmVudEVtaXR0ZXI8e1xyXG4gICAgICAgIHRhYjogc3RyaW5nO1xyXG4gICAgfT47XHJcbiAgICBjb25zdHJ1Y3RvcihuYXZDdHJsOiBOYXZDb250cm9sbGVyKTtcclxuICAgIC8qKlxyXG4gICAgICogQGludGVybmFsXHJcbiAgICAgKi9cclxuICAgIG9uUGFnZVNlbGVjdGVkKGRldGFpbDogU3RhY2tFdmVudCk6IHZvaWQ7XHJcbiAgICAvKipcclxuICAgICAqIFdoZW4gYSB0YWIgYnV0dG9uIGlzIGNsaWNrZWQsIHRoZXJlIGFyZSBzZXZlcmFsIHNjZW5hcmlvczpcclxuICAgICAqIDEuIElmIHRoZSBzZWxlY3RlZCB0YWIgaXMgY3VycmVudGx5IGFjdGl2ZSAodGhlIHRhYiBidXR0b24gaGFzIGJlZW4gY2xpY2tlZFxyXG4gICAgICogICAgYWdhaW4pLCB0aGVuIGl0IHNob3VsZCBnbyB0byB0aGUgcm9vdCB2aWV3IGZvciB0aGF0IHRhYi5cclxuICAgICAqXHJcbiAgICAgKiAgIGEuIEdldCB0aGUgc2F2ZWQgcm9vdCB2aWV3IGZyb20gdGhlIHJvdXRlciBvdXRsZXQuIElmIHRoZSBzYXZlZCByb290IHZpZXdcclxuICAgICAqICAgICAgbWF0Y2hlcyB0aGUgdGFiUm9vdFVybCwgc2V0IHRoZSByb3V0ZSB2aWV3IHRvIHRoaXMgdmlldyBpbmNsdWRpbmcgdGhlXHJcbiAgICAgKiAgICAgIG5hdmlnYXRpb24gZXh0cmFzLlxyXG4gICAgICogICBiLiBJZiB0aGUgc2F2ZWQgcm9vdCB2aWV3IGZyb20gdGhlIHJvdXRlciBvdXRsZXQgZG9lc1xyXG4gICAgICogICAgICBub3QgbWF0Y2gsIG5hdmlnYXRlIHRvIHRoZSB0YWJSb290VXJsLiBObyBuYXZpZ2F0aW9uIGV4dHJhcyBhcmVcclxuICAgICAqICAgICAgaW5jbHVkZWQuXHJcbiAgICAgKlxyXG4gICAgICogMi4gSWYgdGhlIGN1cnJlbnQgdGFiIHRhYiBpcyBub3QgY3VycmVudGx5IHNlbGVjdGVkLCBnZXQgdGhlIGxhc3Qgcm91dGVcclxuICAgICAqICAgIHZpZXcgZnJvbSB0aGUgcm91dGVyIG91dGxldC5cclxuICAgICAqXHJcbiAgICAgKiAgIGEuIElmIHRoZSBsYXN0IHJvdXRlIHZpZXcgZXhpc3RzLCBuYXZpZ2F0ZSB0byB0aGF0IHZpZXcgaW5jbHVkaW5nIGFueVxyXG4gICAgICogICAgICBuYXZpZ2F0aW9uIGV4dHJhc1xyXG4gICAgICogICBiLiBJZiB0aGUgbGFzdCByb3V0ZSB2aWV3IGRvZXNuJ3QgZXhpc3QsIHRoZW4gbmF2aWdhdGVcclxuICAgICAqICAgICAgdG8gdGhlIGRlZmF1bHQgdGFiUm9vdFVybFxyXG4gICAgICovXHJcbiAgICBzZWxlY3QodGFiOiBzdHJpbmcpOiBQcm9taXNlPGJvb2xlYW4+O1xyXG4gICAgZ2V0U2VsZWN0ZWQoKTogc3RyaW5nIHwgdW5kZWZpbmVkO1xyXG59XHJcbiJdfQ==